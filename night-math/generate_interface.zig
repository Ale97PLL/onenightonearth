const std = @import("std");
const fs = std.fs;

const imports = struct {
    pub const star_math = @import("src/star_math.zig");
    pub const math_utils = @import("src/math_utils.zig");
    // pub const log = @import("src/log.zig");
    pub const wasm_interface = @import("src/wasm_interface.zig");
    pub const star_renderer = @import("src/StarRenderer.zig");
    pub const canvas = @import("src/Canvas.zig");
};

fn writeTypescriptTypeName(comptime T: type, writer: anytype) !void {
    switch (@typeInfo(T)) {
        .Int, => |info| {
            if (info.bits >= 64) {
                try writer.writeAll("BigInt");
            } else {
                try writer.writeAll("number");
            }
        },
        .Float => try writer.writeAll("number"),
        .Pointer => |info| switch (info.size) {
            .One, .Many, .C => try writer.writeAll("pointer"),
            else => @compileError("Slices are not valid as arguments in an exported function"), 
        },
        .Optional => |info| {
            try writeTypescriptTypeName(info.child, writer);
            if (@typeInfo(info.child) != .Pointer) {
                try writer.writeAll(" | null");
            }
        },
        .Void => try writer.writeAll("void"),
        else => @compileError("Cannot generate Typescript type for Zig type " ++ @typeName(T)),
    }
}

pub fn main() !void {
    const cwd = fs.cwd();

    var out_file = try cwd.createFile("../web/src/wasm/wasm_module.d.ts", .{});
    defer out_file.close();

    var buffered_writer = std.io.bufferedWriter(out_file.writer());
    defer buffered_writer.flush() catch {};
    
    var writer = buffered_writer.writer();
    
    try writer.writeAll("// This file was auto-generated by night-math/generate_interface.zig\n");
    try writer.writeAll("export type pointer = number;\n");
    try writer.writeAll("export interface WasmModule {\n");
    try writer.writeAll("\tmemory: WebAssembly.Memory;\n");

    inline for (@typeInfo(imports).Struct.decls) |import_decl| {
        inline for (@typeInfo(import_decl.data.Type).Struct.decls) |decl| {
            switch (decl.data) {
                .Fn => |func| {
                    if (func.is_export) {
                        const func_info = @typeInfo(func.fn_type).Fn;
                        try writer.print("\t{s}: (", .{decl.name});
                        if (func_info.args.len > 0) {
                            inline for (func_info.args) |fn_arg, arg_index| {
                                if (fn_arg.arg_type) |arg_type| {
                                    if (arg_index < func.arg_names.len) {
                                        try writer.print("{s}: ", .{func.arg_names[arg_index]});
                                    } else {
                                        try writer.print("arg_{}: ", .{arg_index});
                                    }
                                    try writeTypescriptTypeName(arg_type, writer);
                                    if (arg_index < func_info.args.len - 1) {
                                        try writer.writeAll(", ");
                                    }
                                }
                            }
                        }
                        try writer.writeAll(") => ");
                        try writeTypescriptTypeName(func_info.return_type orelse void, writer);
                        try writer.writeAll(";\n");
                    }
                },
                else => {},
            }
        }
    }

    try writer.writeAll("};\n");

}